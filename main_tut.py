# python built in functions
"""
comments -- the basics -- before we get fancy we should use
1) built ins
2) well documented and tested libraries
3) build yourself, but use decent algorithms, and incorporate #1 and #2
"""

print("====================================")
print("abs()")
print("abs(-5) absolute value of a number, gives {}, error if not number".format(abs(-5)))
print("====================================")
print("all()")
print("all(x) is true if all x, which is a iterable, is true")
x = [1, 2, 3, 4, 5, 6, 7, 8]
print("so, given x = [1,2,3,4,5,6,7,8] , (all(x)) gives: ", (all(x)))
x = [1, 2, 3, 4, 5, 6, 7, 0]
print("so, given x = [1, 2, 3, 4, 5, 6, 7, 0] , (all(x)) gives: ", (all(x)))
print("====================================")
print("any()")
print("any(x) is true if any x, which is a iterable, is true")
print("so, given x = [1, 2, 3, 4, 5, 6, 7, 0] , (any(x)) gives: ", (any(x)))
x = []
print("so, given x = [] , (any(x)) gives: ", (any(x)))
print("====================================")
print("ascii()")
print("As repr(), return a string containing a printable representation of an object,")
print("but escape the non-ASCII characters in the string returned by repr() ")
print('using back tick x, back tick u or back tick U escapes.')
print("ascii('ttt') gives {}".format(ascii('ttt')))
print("====================================")
print("bin()")
print("Convert an integer number to a binary string")
print("bin(4) gives {} , a binary string and is type {}".format(bin(4), type(bin(4))))
print("====================================")
print("bool()")
print("Return a Boolean value, i.e. one of True or False")
print("bool(0) gives {}, and bool(1) gives {}".format(bool(0), bool(1)))
print("====================================")
print("bytearray()")
print("Return a new array of bytes.")
print("bytearray('test') gives {}".format(bytearray('test', 'utf8')))
print("====================================")
print("bytes()")
print("bytes is an immutable version of bytearray")
print("bytes('tester') gives {}".format(bytes('tester', 'utf8')))
print("====================================")
print("callable()")
print("Return True if the passed object argument appears callable, False if not")
print("callable(str) returns {}".format(callable(str)))
print("====================================")
print("chr()")
print("Return a string of one character whose ASCII code is the integer i.")
print("chr(97) evaluates to >{}<".format(chr(97)))
print("====================================")
print("classmethod()")
print("Return a class method for function.")
print("The @classmethod form is a function decorator")
print("====================================")
print("compile()")
# put this in to suppress PyCharm errors -- as ppp is being dynamically compiled below
ppp = 0
print("compile is the low level way to dynamically run up code")
print(
    "Compile the source into a code or AST object. Code objects can be executed by an "
    "exec statement or evaluated by a call to eval().")
zzz = compile("ppp=99", '<string>', 'exec')
exec(zzz)
print("zzz=compile('ppp=99','<string>','exec') , then executing exec zzz, then printing ppp gives {}".format(ppp))
print("====================================")
print("complex([real[, imaginary]])")
print("Return a complex number with the value real + imaginary*j or convert a string or number to a complex number. ")
print("complex(10,-5) returns {}".format(complex(10, -5)))
print("====================================")
print("delattr(object, name)")
print("The function deletes the named attribute of the object, provided the object allows it. ")
print("====================================")
print("dict()")
print("creates a dict, with either an mapping and iterable or kwargs")
print("dict(one=1, two=2, three=3) prints {}".format(dict(one=1, two=2, three=3)))
print("====================================")
print("dir()")
print(
    "Without arguments, return the list of names in the current local "
    "scope. With an argument, attempt to return a list of valid attributes for that object.")
print("So, dir() is {}".format(dir()))
print("====================================")
print("divmod()")
print(
    "Take two (non complex) numbers as arguments and return a pair of numbers "
    "consisting of their quotient and remainder when using long division")
print("divmod(7,2) gives {}".format(str(divmod(7, 2))))
print("====================================")
print("enumerate()")
print("with a passed iterable, creates an iter object that return a tuple with the pos,val")
print("enumerate([1,2,3,4,5]).next() gives {}".format(str(next(enumerate([1, 2, 3, 4, 5])))))
print("====================================")
print("eval()")
print("The return value is the result of the evaluated expression (string)")
print("eval(7+2) is {}".format(eval('7 + 2')))
print("====================================")
print("execfile()")
print("This function is similar to the exec statement, but parses a file instead of a string.")
print("====================================")
print("filter()")
print("filter(function, iterable)")
print("Construct a list from those elements of iterable for which function returns true.")
print("filter(lambda x:x<5 , range(10)) gives {} ".format( [x for x in range(10) if x < 5]))
print("====================================")
print("float()")
print("Return a floating point number constructed from a number or string x")
print("float(4.5) is {0} and has type of {1}".format(float(4.5), type(float(4.5))))
print("====================================")
print("format()")
print("Convert a value to a 'formatted' representation, as controlled by format_spec.")
print("see the format spec")
print("format(10000000, ',') gives {} ".format(format(10000000, ',')))
print("====================================")
print("frozenset()")
print("creates a frozen set -- a specific immutable py type, from an iterable")
print("frozenset([1,2,3,4,5]) gives {}".format(frozenset([1, 2, 3, 4, 5])))
print("====================================")
print("getattr()")
print("This is the counterpart of setattr(). The arguments are an object, and a string name. ")
print("used on objects ....")
print("getattr('123', 'isalpha') gives {}".format(getattr('123', 'isalpha')))
print("====================================")
print("globals()")
print("Return a dictionary representing the current global symbol table. ")
print("globals() gives {}".format(globals()))
print("====================================")
print("hasattr()")
print("This is the counterpart of setattr(). The arguments are an object and a string name. ")
print("used on objects calls getattr and checks for an exception....")
print("hasattr('gg', 'monkey') gives {}".format(hasattr('gg', 'monkey')))
print("====================================")
print("hash()")
print("Return the hash value of the object (if it has one). ")
print("hash('a') gives {}".format(hash('a')))
print("====================================")
print("help()")
print("Invoke the built-in help system.")
print("help(str) gives a man page dump of help (not doing it here)")
print("====================================")
print("hex()")
print("Convert an integer number (of any size) to a lowercase hexadecimal string prefixed with '0x'")
print("hex(25) gives {}".format(hex(25)))
print("====================================")
print("id()")
print("Return the 'identity' of an object.")
print("id(44) is {}".format(id(44)))
print("====================================")
print("input()")
print("reads from the standard input..")
print("====================================")
print("int()")
print("Return an integer object constructed from a number or string x")
print("int(4.5) is {} and has type of {}".format(int(4.5), type(int(4.5))))
print("====================================")
print("isinstance()")
print("Return true if the object argument is an instance of the class info argument")
print("isinstance('g', str) gives {}".format(isinstance("g", str)))
print("====================================")
print("issubclass()")
print("Return true if class is a subclass (direct, indirect or virtual) of class info.")
print("Used in class programming")
print("====================================")
print("iter()")
print("Return an iterator object. Object must be a kind of sequence")
print("iter([1,2,3,4,5]) gives {}".format(iter([1, 2, 3, 4, 5])))
print("====================================")
print("len()")
print("Return the length (the number of items) of an object.")
print("len([1,2,3,4]) is {}".format(len([1, 2, 3, 4])))
print("====================================")
print("list(iterable)")
print("Return a list whose items are the same and in the same order as iterable's items.")
print("list('abc') is {}".format(list('abc')))
print("====================================")
print("locals()")
print("Update and return a dictionary representing the current local symbol table.")
print("locals() returns {}".format(locals()))
print("====================================")
print("map()")
print("map a function to an iterable")
print("map((lambda x:x+x),[1,2,3,4,5,6]) gives {}".format(list(map((lambda x: x + x), [1, 2, 3, 4, 5, 6]))))
print("====================================")
print("max()")
print("Return the max amount of an iterable, or of a number of arguments")
print("max([55,33,234,5,1,-2]) is {}".format(max([55, 33, 234, 5, 1, -2])))
print("====================================")
print("memoryview()")
print("Return a 'memory view' object created from the given argument.")
print("not used much")
print("====================================")
print("min()")
print("Return the smallest item in an iterable or the smallest of two or more arguments.")
print("min([55,7,33,24,5,6,2) is {} ".format(min([55, 7, 33, 24, 5, 6, 2])))
print("====================================")
print("next()")
print("Retrieve the next item from the iterator by calling its next() method. ")
print("next(iter([22,33,44,55])) is {}".format(next(iter([22, 33, 44, 55]))))
print("====================================")
print("object()")
print("Return a new featureless object")
print("object() returns {}".format(object()))
print("====================================")
print("oct()")
print("Convert an integer number (of any size) to an octal string.")
print("oct(66) gives {}".format(oct(66)))
print("====================================")
print("open()")
print("Open a file (passed in as a string), returning an object of the file type")
print("====================================")
print("ord()")
print(
    "Given a string of length one, return an integer representing the Unicode "
    "code point of the character when the argument is a unicode object")
print("ord('a') is {}".format(ord('a')))
print("====================================")
print("pow()")
print("Return x to the power y;")
print("pow(2,5) is {}".format(pow(2, 5)))
print("====================================")
print("print()")
print("Print objects to the stream file -- THIS IS MANDATORY IN PY 3 --GET USED TO IT")
print("====================================")
print("property()")
print("Return a property attribute for new-style classes (classes that derive from object).")
print("Mostly used as a decorator to give a nice name to a function that can be called as an attribute")
print("====================================")
print("range()")
print(" create lists containing arithmetic progressions., start, stop ,step as args")
print("range(5,11,2) gives {}".format(list(range(5, 11, 2))))
print("====================================")
print("repr()")
print("Return a string containing a printable representation of an object. ")
print("repr('test') returns {}".format(repr('test')))
print("====================================")
print("reversed()")
print("Return a reverse iterator from a passed seq")
print("reversed([1,2,3]) gives {}".format(reversed([1, 2, 3])))
print("====================================")
print("round()")
print("Return the floating point value number rounded to n-digits digits after the decimal point.")
print("round(6.6456,2) gives {}".format(round(6.6456, 2)))
print("====================================")
print("set()")
print("Return a new set object, optionally with elements taken from iterable. set is a built-in class. ")
print("if a,b,c,d == 1, then set([a,b,c,d]) (code uses set literal though) gives {}".format({1, 1, 1, 1}))
print("====================================")
print("setattr()")
print("This is the counterpart of getattr(). The arguments are an object, a string and an arbitrary value. ")
print("used on objects -- kinda like monkey patching to me....")
print("====================================")
print("slice()")
print(
    "returns a slice object, used by library writers so y=slice(1,11,3)"
    " has a start,stop and step indexes, y.step = {}".format(slice(
        1, 11, 3).step))
print("====================================")
print("sorted()")
print("a NEW, sorted copy of an iterable")
print("sorted([5,3,2,6,5]) gives {}".format(sorted([5, 3, 2, 6, 5])))
print("====================================")
print("staticmethod()")
print("Return a static method for function. Used in classes -- gets rid of the 'self'")
print("====================================")
print("str()")
print("Return a string containing a nicely printable representation of an object.")
print("str('test') is {}".format(str('test')))
print("====================================")
print("sum()")
print("Sums start and the items of an iterable from left to right and returns the total.")
print("sum(range(101)) gives {}".format(sum(range(101))))
print("====================================")
print("super()")
print("super (type, object) Return a proxy object that delegates method calls to a parent or sibling class of type")
print("This changed a lot in 3 -- so I'm ignoring till 3 -- so I guess I have to address this!")
print("====================================")
print("tuple()")
print("Return a tuple whose items are the same and in the same order as an iterable item.")
print('tuple([1,2,3,4,5]) returns {} and has type of {}'.format(tuple([1, 2, 3, 4, 5]), type(tuple([1, 2, 3, 4, 5]))))
print("====================================")
print("type()")
print("2 uses -- called as type(object) gives the type")
print("called with type(name, bases, dict) -- creates a new class")
print("type(1) gives {}".format(type(1)))
print("type('yy', str, dict(a=1)) gives {}".format(type('yy', (object,), dict(a=1))))
print("====================================")
print("vars()")
print("Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute.")
tst = type('yy', (object,), dict(a=1))
print("vars(tst) (where tst is type('yy', (object,), dict(a=1))) gives {}".format(vars(tst)))
print("====================================")
print("zip()")
print(
    "This function returns a list of tuples, where the i-th tuple contains "
    "the i-th element from each of the argument sequences or iterables.")
print("zip([1,2,3], [4,5,6]) gives {}".format(list(zip([1, 2, 3], [4, 5, 6]))))
print("====================================")
